解析した情報のメモなど
rev84
-----------------------------------------------------------------------------------------------------

*プログラムアドレス(bank:pcの形) からファイルのアドレスへの変換
	bank>>7 + (pc & 0x1fff) 要はbankを2倍して桁を右にずらしてpcの下位13bitを足す
	通常ヘッダがあるのでその分(0x10)も足す


*戦闘抑止(エンカウントエフェクトはあり)
	$3e:c049 20 8a c9 jsr $c98a
	=> 60 rts

*チェンジ可能なジョブ判定
	メニューに表示しようとするジョブのIDが
	$3f:f38a(getLastValidJobId)の戻り値以下であれば有効とみなされる
	よって0から指定のIDまで連続でしか有効/無効を設定できない(飛び番とかは無理)
	他の制限(Lv・装備)はメニューで実際に選択されたときに行う

	$f394:	a2 05	ldx #$05	;05:あかまどうし (風のクリスタル後)
	$f399:	a2 09	ldx #$09	;09:がくしゃ (火)
	$f39e:	a2 10	ldx #$10	;10:ぎんゆうしじん (水)
	$f3a3:	a2 13	ldx #$13	;13:まかいげんし (土)
	$f3a8:	a2 30	ldx #$30	;30:??? (エウレカ)

*打撃モーションの設定
	片手あたりの武器を振る上限(値は含まない=設定5なら4回まで)
	//index: blowType
	$33:a077(file:66087) blowEffect_swingCountBoundForWeaponTypes = {
		07 05 05 07 05 07 07 07 07
	}

	どの値を使うかは
	//index: itemid
	$2e:9098(file:5d0a8) BlowEffectParam params[];
	にある各武器ごとの3バイトデータ:
	struct BlowEffectParam {
		u8 weaponBlowType;	//打撃モーション
		u8 spriteIndex;	//index to 10h bytes data (base = $2b:b000)
		u8 color?;	//unk1;
	};
	の1バイト目
	設定値は以下のとおり:
	enum weaponBlowType {
		fist = 0,	//素手
		axe = 1,	//斧
		spear = 1,	//槍
		sword = 1,	//剣
		rod = 2,	//棒,杖
		book = 2,	//本
		bell = 2,	//ベル
		bow = 3,	//弓
		harp = 4,	//竪琴
		boomerang = 5,	//ブーメラン
		ring = 6,	//円月輪
		shuriken = 7,	//手裏剣
		arrow = 8,	//矢
		claw = 9	//爪
	};
	オリジナルでは0(素手),1(剣etc),2(本etc),8(矢),9(爪)は一振り8フレーム
	その他はだいたい全体で16フレーム
	それぞれルーチンにハードコーディング


*分裂判定
	打撃が命中した相手の行動リストの先頭が4Fhなら攻撃属性チェック
	暗黒以外なら分裂
	二刀流の場合は命中した手によらず両手が暗黒でないと分裂(未確認)
	分裂の際ステータス効果はクリアされるが
	ステータスキャッシュの2バイト目をクリアしないので徐々に石化などはおかしい
	オリジナルでは行動4Fを持つ敵の特殊攻撃率は0だが
	4fを行動として選択した場合は「ようすをみている」になる


*移動手段の速度設定
	//index: vehicle
	$3e:cd76 vehicleSpeeds[] = {
		01 02 01 02 04 02 08 02
	};
	以下ラビリオンズ(http://rabirion-web.hp.infoseek.co.jp/address.html)さんより拝借
		>(0-歩行、1-チョコボ、2-カヌー 3-船、4-飛空艇、5-シドの飛空艇
		>6-ノーチラス、7-インビンシブル)
	設定値の意味は1フレームに何pixel進むか(1歩=16)(徒歩が1なので徒歩のx倍という見方も可)
	ただし2のn乗(n=0-3) でないとバグる
	なお8の場合は移動開始時のみ4扱いされる


*属性ボーナス
	元々オリジナルに実装はされているがフラグのセットとクリアが逆になっている
	(装備変更初期化時にセット・パラメータ計算後クリア)
	ボーナスは攻撃回数を割増する形で適用
	$31:b0bf($630bf) a9 05 lda #$05 ;この値で攻撃回数を割って追加ボーナスとする


*item99バグ
	;この時点でxは個数へのオフセット
	;空欄検索ループはxにidへのオフセットを期待する
	$35:bfc7(6bfd7): 
		B0 0E bcs $bfd7 ; 増加後itemの個数が100個以上なら分岐(空欄検索ループの中)
	下のどちらかで修正可:
		B0 25 bcs $bfee ; 追加に失敗して終わる(取得メッセージも出ない)
		B0 0C bcs $bfd5 ; 空欄を探す(同じアイテムが二つの欄にまたがって配置される,他でバグる可能性あり)
	

*ダメージ表示
	$33:ad2b effect_0C	//damageEffect
	//	[in] u8 $7e6f : side (0 = player)
	//	[in] damage $7e4f[8] : damages
	//	struct damage {
	//		u16 damage : 14;	//表示する値 3FFFで 表示無し
	//		u16 miss : 1;		//1なら damage == 3fffでない限りミス!と表示
	//		u16 heal : 1;		//1なら数字の色が緑($56-の代わりに$66-のタイルを使用,パレットは同じ)
	//	};

*ダメージ倍率255バグ
	$31:a264:
	//$74:count of character who tries to escape
	if ( ($74 != 0) //beq a288
		&& (getActor2C() < 0)) //bpl a288
	{	
		//secが無い
		//ミスの場合最後にcarryに影響を与えるのは$9fdc
		//$9fdcは攻撃成功回数から防御成功回数を引いている
		//よってミス(命中回数0= 攻撃成功回数<=防御成功回数)の場合
		//carryはクリアされていることがある(その結果1余計に引く)
		//
		$70[y = #27] -= 1;	//ダメージ倍率 $74!=0の場合前半で一時的に1たされる
		if ($7c != 0) { //beq a288
			$78da.(x = $78ee) = #55; //"にげごしで ぼうぎょできなかった!"
			$78ee++;
		}
	}

*召還魔法の計算等
	行使者の能力を元に戦闘キャラ構造体を生成し
	それを以後の計算に渡して計算している
	生成されたキャラのLvが熟練度の2倍になるのが高威力の元くさい

	$34:9ff2:
		;$57 は行使したキャラの基本情報構造体へのポインタ($6100-)
		lda ($57),y	;ジョブ
		cmp #$13	;13=まかいげんし
		beq $a009
		cmp #$14	;14=けんじゃ
		beq $a009

	$35:a022:
		lda #$0f
		jsr $9b88	;setYtoOffsetOf
		ldx #$02
	$a029:
		;$5b は行使したキャラの戦闘キャラ構造体へのポインタ($7575-)
		lda ($5b),y	;y=f,10,11 = 熟練度,知性,精神
		asl a		;2倍
		sta $18,x	;逆順に保存
		iny
		dex
		bpl $a029
	;...
	$a03f:
		ldy #$0f
		ldx #$02
	$a043:
		;$6e は召還獣へのポインタ (以後の計算において行動者扱い)
		lda $18,x
		sta ($6e),y
		iny
		dex
		bpl $a043
	$a04b:
		ldy #$00	;Lv = 
		lda $1a		; 熟練度 ($18+2) * 2
		sta ($6e),y	;


*戦闘キャラ用データ(プレイヤー:$7575-,敵:$7675-)
	40hバイト
	struct BattleCharacter {
		u8 lv;		//00
		u8 status00;	//01 死亡etc 永久
		struct LiteBadStatus {
			u8 jumping : 1;		//戦闘時のみ(追加効果用データの時はステータス種選択フラグ)
			u8 petrifyLevel : 2;	//overflowしたら石化
			u8 remainLevel : 2;	//被打撃時に-1, 0で以下3種のステータス回復。睡眠と麻痺はターン経過でも-1
			u8 confused : 1;
			u8 sleeping : 1;
			u8 paralyzed : 1;
		};
		u16 hp;		//03
		u16 maxHp;	//05
		union {
			struct {
				u8 mp[8];
			} player;
			struct {
				u8 unk[7];
				u8 actionListId;
			} enemy;
		} _07_0E;	//07-0E
		u8 jobLevel;	//0F
		u8 int;		//10 (enemy: param[7] & 0x0F * 6)
		u8 men;		//11 (enemy: param[7] & 0xF0 * 3 / 8)

		struct {
			u8 weakAttr;	//12
			u8 count;	//13
			u8 evade;	//14
			u8 power;	//15
		} mdef;
		struct AttackProperty {
			u8 attr;	//16 1b
			u8 count;	//17 1c
			u8 hit;		//18 1d
			u8 power;	//19 1e
			u8 enchant;	//1a 1f
		};
		AttackProperty right;
		AttackProperty left;	//敵は未使用ぽい
		struct {
			u8 attr;	//20
			u8 count;	//21
			u8 evade;	//22
			u8 power;	//23
			u8 resist;	//24
		} def;
		u8 unk0[2];
		u8 damageMultiplier;	//27 (1:x2, 2:x3) (jump:2)
		u8 criticalRate;	//28 (enemy: 5, player: jobParam[0] )
		u8 criticalBonus;	//29 (enemy: atk/2, player: jobParam[1] )
		u8 escapeBaseRate;	//2a (jobparam_02)
		u8 jobparam_03;		//2b
		
		struct {
			u8 index : 3;
			u8 actionMode : 2;
			u8 unk : 2;
			u8 isEnemy : 1;
		} indexAndMode;	//2c
		
		u8 unk1;	//2d
		u8 actionId;	//2e
		u8 targetBits;	//2f (bit7: target=index0 ... bit0: index7)
		struct {
			u8 unk : 6;
			u8 multipleTarget : 1;
			u8 targetAtEnemySide : 1;
		} targetFlag;	//30

		//80:盾 08:竪琴(idチェック無しで遠距離扱い) 04:矢(弓装備時) 02:弓(矢装備時)  01:片手武器 00:それ以外
		WeaponType right,left;	//31-32
		struct {
			u8 position : 1; //1 = 後列
			u8 equipFlag : 2; //(素手:00 片手:02 両手遠距離(竪琴):04 弓(矢装備時):06)
			u8 unk : 2;
			u8 attrBoost : 3; //>>3された上で使用技の属性とand,1ならヒット数20%増加
		} miscFlags;	//33

		u8 unk2;	//34
		union {
			u8 jobExpMultiplier;	//35 player
			u8 firstActionId;	//35 enemy
		};
		u8 dropListIndex;	//36
		u8 specialRate;		//37
		union {
			struct {
				u8 actionId[8]; //38-3f
			} enemy;
			struct {
				u8 bonusAtk[2];
				u8 unk[4];
				u8 usedItemIsEquipment;
				u8 usedItemId;
			} player;
		} _38_3f;
	};

*行動パラメータ
	struct MagicParam {
		u8 attr;	//+00
		u8 hit;		//+01
		u8 power;	//+02
		u8 enchant;	//+03
		u8 handlerIndex;//+04
			u8 unk1 : 4;
			u8 dependsOnMen : 1; //1 = men
			u8 allowMultipleTarget : 1;
			u8 targetAll : 1;
			u8 targetDefaultsPlayerSide : 1;
		u8 effectType; 	//6=死亡チェック省略(分裂系が該当)
		u8 invokerType;	//+07
	};

*逃走成功率
	(味方) 成功率(%) = max(0, 試行キャラ基本逃走成功率 + 25 - 敵平均Lv)
	基本逃走成功率はジョブパラメータの3バイト目
	計算式上中盤以降の敵から逃げるのは絶望的
	$35:a915:
		a0 2a	ldy #$2a	;2a:基本逃走成功率
		b1 6e	lda ($6e),y
		18	clc
		69 19	adc #$19	;+25
		38	sec
		e5 1c	sbc $1c		;-敵平均Lv
		b0 02	bcs $a923	;結果が正なら分岐
		a9 00	lda #$00	;負になったので成功率0扱いとする
	$a923:
		85 24	sta $24		;成功判定の閾値として保存

*応援の効果
	味方全員の右手攻撃力+10(左手は上がらない)

*脅かすの効果
	敵全体のLv= 最初の敵のLv-3

*ステータス解除が効かないバグ -------------------------------------------------------------------------
	対象と使用者が同じ場合結果が使用者の
	使用前のステータスで上書き(OR)される


*ステータス効果適用までの流れ -------------------------------------------------------------------------
[ステータス魔法]
	攻撃回数計算[汎用]
	属性ボーナス適用[汎用]

	=>$31:b30c ステータス魔法ルーチン(special04) 
	不死チェック [汎用] =>不死なら別ルーチンにジャンプ(未調査)
	ヒット回数計算(防御回数適用) [汎用] => 結果がミスなら終了
	対象が敵でかつ$7ed8のbit7が立っていたら(=ボス戦?)終了 ($31:b32e付近)
	混乱か蛙を適用しようとしていて対象が既に石化していたら終了
	耐性チェック =>
		適用ステータスとAND,軽症(徐々に石化・混乱・眠り・麻痺)と重症(その他)のbitの意味が被る
		耐性があれば(and後0でなければ)終了
	キルの場合は対象のLvが使用者Lvの3/4以下でなければ終了
	ステータス適用ルーチンにジャンプ

	=>$31:bbf3 ステータス適用ルーチン
		適用効果が重症(毒・暗・小・黙・蛙・石・死、右にいくほど重い)の場合(bit0が0):
			対象がより重いステータスに既にかかっているならなにもしないで終了
			でなければ効果適用
		軽症(徐々に石化・混乱・眠り・麻痺)の場合(bit0が1):
			ボス戦($7ed8のbit7が1)で 適用効果が混乱以外の場合終了 ($31:bc2a付近)
			徐々に石化の場合(bit1-2がともに1):
				対象の石化度(bit1-3)に適用効果のbit1-7を足す
				ステータス値全体でみて結果が8以上なら石化させて石化度をクリア
				打撃によるものならメッセージ("からだがじょじょにせきかする")設定
			適用効果が徐々に石化以外の場合:
				対象がより重いステータスならなにもしないで終了
				でなければ効果適用、混乱なら対象の行動をキャンセル
[打撃]
	ミスか対象が死んでいる場合は判定なし
	ボス戦なら判定なし	($31:a129付近)
	攻撃者が小人か蛙なら判定なし
	でなければ成功判定ルーチンに飛ぶ
	=> $31:be14 追加効果成功判定
		(命中-回避)(%)でヒット回数分命中判定 ; 回避の方が高い場合は成功率0%で判定
		1回でもあたったらステータス適用ルーチンに飛ぶ

[トード/ミニマム]
	味方のパーティアタックだったら回避0扱い
	ボス戦かつ対象が敵なら終了
	でなければ対応するビットを反転,メッセージ設定

[イレース]
	$31:b49b(634ab):
	20 e7 b8	jsr $b8e7	;魔法回避を攻撃回数から引く
	f0 18		beq $b4b8	;ミスならジャンプ(効果なしで終了)
	20 25 bc	jsr $bc25	;対象の+2c(行動種,敵フラグ,キャラ番号) を取得
	10 0b		bpl $b4b0	;味方ならジャンプ(効果適用)
	ad d8 7e	lda $7ed8	;戦闘モードフラグ 80:ボス戦 20:大砲援護 10:小人回復禁止 01:逃走禁止
	$b4a8:
	10 06		bpl $b4b0	;ボス戦でなければジャンプ(効果適用)
	;対象が敵かつボス戦なら到達
	20 26 b9	jsr $b926	;エフェクトを表示する対象をクリア
	4c b8 b4	jmp $b4b8	;(効果無しで終了)
	$b4b0:	;それ以外
	a0 20		ldy #$20	;戦闘キャラ構造体+20をオフセットとする
	b7 70		lda ($70),y	;+20: 耐性属性(のはず)
	29 03		and #$03	;上位6ビット(吸収と暗黒以外)をクリア
	91 70		sta ($70),y	;保存
	$b4b8:
	60		rts		;終了

	回避適用[汎用]
	対象が敵かつボス戦なら終了
	でなければ戦闘キャラ構造体+20(耐性属性)を#3でANDして保存

[プロテス]
	$31:b704(63714) a0 23 b7 70 c9 ff d0 08...
		b704- 現ステチェック (防御力!=255 && 魔法防御力!=255)
		b714- 防御力 += 魔法ダメージ
		b72b- 魔法防御力 += 魔法ダメージ
		b742  表示ダメージ設定ルーチン呼び出し = 非表示(FFFF)
[ヘイスト]
	$31:b752(63762) a0 19 b1 70 c9 ff f0 67...
		b752- 現ステチェック(攻撃力<255 && 攻撃回数<16)
		b772- 右手の攻撃力 += 魔法ダメージ
		b789- 左手
		b7a0- 右手の攻撃回数 += 魔法ヒット数
		b7af- 左手
		b7be 表示ダメージ設定ルーチン呼び出し = 非表示(FFFF) 

*逆吸収時の数字がおかしいバグ ------------------------------------------------------------------------
	攻撃対象が聖属性に弱い場合与えたダメージを攻撃者に適用するが
	その後ポインタを攻撃側のままにして今度は回復処理を行う
	打撃の場合回復値はダメージの1/4なので実質3/4ダメージ入ることになるが
	ダメージを入れたときに死んだ場合死亡フラグが立ち
	その後死体にヒールが入る
	表示されるダメージはこの処理を呼び出す打撃処理が
	処理前HPから処理後HPを引いた値に設定するため
	ダメージ上HPが残るように見えても死ぬことがある
	
	またこの処理によって不死である対象が回復することはない
	おそらくドレインもこの処理を呼び出しているが
	打撃でない場合 回復値=ダメージ なので
	受けたダメージに耐え切るHPがあれば結果的にノーダメージと変わらない(なければ死ぬ)
	$31:bd67 spoilHp
	//in:
	//	u16 $78,79 : damage
	//	ptr $70 : target
	//	ptr $6e : actor
	//out:
	//	u8 $26 : dead flag (00:both alive 01:target dead 81:actor dead)
	//	u8 $42 : undead flag
	{
		$26 = 0;
		if (isTargetWeakToHoly() ) { //$bbe2(); bcc bd8f
	$bd70:
			//undead
			$42++;
			setCalcTargetToActor();	//$bdb3
			damageHp();	//bcd2
			if (!carry ) {	// bcs bd7e
	$bd7a:	
				//damage target(= actor) dead
				$26 = #81
			}
	$bd7e:
			if ($6e[y = #2e] == #04) { //bne bd89
				shiftRightDamageBy2();	//$bdaa();
			}
			//本来の意図はここで対象のHPを回復することだと思われる
			//($bdbc にちょうどいいポインタを設定する処理がある)
			healHp();	//$bd24();
			//goto bda9
		} else {
	$bd8f:
			damageHp();	//bcd2
			if ( !carry ) { //bcs bd98
				$26 = #01
			}
			setCalcTargetToActor();	//bdb3
			if ($6e[y = #2e] == #04) { //bne bda6
				shiftRightDamageBy2();	//$bdaa();
			}
	$bda6:
			healHp();	//$bd24();
		}
	$bda9:
		return;
	}

*ダンジョン階層移動バグ --------------------------------------------------------------------------------
	$3f:e299:
		tsx
		cpx #$20

	「降りる」音がする場所ではまずスタックポインタが20h以上であるかチェックする
	もし20h未満であれば移動処理はしないで他の処理を続ける
	20h以上であれば現座標とMAPIDと思われるものをスタックに保存してから
	自身($3f:e1dc dungeon_mainLoop)を呼び出す
	$29(x?),$2a(y?),$48(mapid?)と戻りアドレスで計5バイトが「降りる」ごとに消費される
	「登る」と戻るがMAPによっては両側が「降りる」になっているものもあり
	そのような場所ではスタックが仕様限界に達するまで消費されていく
	スタックは256バイトで32バイト残すようになっているので224バイト使うまで呼び出せることになり
	これを5で割ると44でデジョンの最大値45-1になっている

	$3f:e1dcはエンカウント処理も行っており仕様上最悪スタックポインタが20hの状態で
	戦闘開始処理を呼び出す
	ff3のIRQとNMIはそれぞれ$0100,$0103とスタック領域の底に割り当てられていて
	状況に応じて特定のハンドラにジャンプするようなコードが書き込まれる
	よって安全に使えるのは$0106までとなり戦闘中に使用される処理は
	戻りアドレスも含めて1Ahバイトしかスタックを使えないことになるが
	エフェクト表示処理など考慮されてないものもあり極限状態ではほぼ確実にバグる
	割り込みがかかるとそれだけで3バイト使用してしまうため
	IRQ中に呼び出されるサウンドドライバーとも相性が悪い
	(サウンドドライバー自体は軽く設計されている感じだが)
	
	スタックの限界とされている20hは適当に決めたか戦闘処理の担当者が理解していないか
	極限状態で戦闘するのが想定外なのかとにかくあてにならない
	40hほど残っていればオリジナルではだいたい正常動作できるようだ

*ステータス画面に表示される「次のレベルまで」
$3f:f239 field::decodeString::OnCode10_13:
//	[in] u8 a : playerIndex
{
	$67 = ((a & 3) << 6) & #c0; //lsr ror ror
	if ($84 >= #0) { //bcc f299
		if ($84 == #ff) { //bne f289
$f24a:
			x = $67;
			if ($6101.x < #62) { //bcs f291
$f253:			//lv < 98 (表示上はLv99)
				$80 = a; //lv
				$84,85 = #8000 + (a << 1 + $80); //lv*3
				call_switch1stbank(per8k:a = #39); //ff06
$f268:
				$80,81,82 = $84[y = #b0,b1,b2] - $6103,6104,6105;
				switchBanksTo3c3d(); //f727
				$3c:8b78();
				//jmp f291
$f24a:
	a6 67    ldx $67
	bd 01 61 lda $6101,x
$f24f:	c9 62    cmp #$62
	b0 3e    bcs $f291
$f253:

*魔法グラフィックの表示 --------------------------------------------------------------------------------
	グラ指定: $5d1d0から3バイトずつ
	フレーム情報アドレス指定($0c000からのオフセット) : $0cc00
	フレーム情報(最大100hバイト、データの先頭が長さ) : ↑
	フレームデータ(配置情報)アドレス指定($00000からのオフセット) : $01708
	配置情報(最大24hバイト) : ↑

	[手順詳細]
	処理手順が複雑なのでフレアの例を併記
	1) 行動id($7e88)をindexにして $2e:91d0($5d1d0)からの3バイトデータを読み込む
		struct EffectLoader {
			u8 unk : 6;
			u8 indexHigh : 1;
			u8 copyUsingLoader6 : 1; //base が9700になる
			u8 indexLow;
			u8 paletteIndex?;	//$33:a440のパラメータ
		};
		flare = { 00 91 bd }

	2) 上記構造体のindexを10h倍して$2a:9600($55600)からのオフセットとする
		flare = 9600+910 = $2a:9f10(55f10)

	3) $33:beb2にある6バイト構造体の8番目を使って(2)のアドレスからVRAMに
	   エフェクト用のパターンをコピーする
		struct CopyToVramParam { //$3f:f970 copyToVram のパラメータ
			u16 srcOffset;
			u16 vramOffset;
			u8 unk : 2;
			u8 per40hSize : 6;
			u8 srcPer16kBank;
		};

	4) 行動id($7e88)をindexにして $06:8c00($0cc00)からのポインタ配列からポインタを取得
		flare = $8cb6

	5) 取得したポインタをbank$06のアドレスとして100hバイトのデータを読み込む
	   実際に100hバイト使い切る必要はない
		struct EffectFrameParam {
			u8 paramId : 7;	//ff:reverse-y flag (set reverse-y mode,fetch more 1byte and treat it as usual)
			u8 reverseX : 1;
		};
		struct EffectFrameStream {
			u8 size;
			EffectFrameParam frames[];
		};
		flare = $06:8cb6($0ccb6)
		{
			08
			2F 30 31 32 2F 30 31 32
		}

	6) (5)で取得した最大100hバイトのデータからフレーム毎に順次
	   配置定義idを取得しindexとして $00:9708からのポインタ配列からポインタを取得
	   反転フラグが立っている場合は座標系を変える(基本は左上が原点)
		flare(1st frame) = $9bd3 = [$9708+0x2F*2]

	7) (6)のポインタをbank$00のアドレスとして24hバイトのデータを読み込む
	   実際に24hバイト使い切らなくてもよい
		union EffectTileParam {
			struct {
				u8 tileIndex : 5;
				u8 reverseHorizontal : 1;
				u8 reverseVertical : 1;
				u8 repeat : 1;
			};
			u8 repeatCount;	//if repeat flag = 1,next byte contains this
		};

	8) (7)で取得したデータを使って6x6にスプライトを配置する
	   タイル番号は7Fなら00扱いとしその他の場合は+49hされる
	   (3)でコピーした先のVRAMアドレスは$1490のため
	   単にグラフィックデータの始まりから番号と思えばよい
	   ここでの反転フラグはそのタイルのみを反転する
		flare = 
		frame0/4 (2f): $00:9bd3 = *$00:9766 (9766= 9708+2f*2)
			00 01 7F 02 03 7F
			40 41 7F 42 43[FF
			02]04 05 7F 00 01
			7F 06 07 7F 40 41
			02 03 7F 04 05 7F
			42 43 7F 06 07 7F
		frame1/5 (30): $00:9bf7
			02 03 7F 04 05 7F
			42 43 7F 06 07[FF
			05]         02 03
			[FF04]      42 43
			04 05[FF04]     
			06 07[FF04]
		frame2/6 (31): $00:9c12
			04 05[FF04]
			06 07[FF05]
			   00 01 7F 04 05
			7F 40 41 7F 06 07
			[FF03]   00 01[FF
			04]      40 41 7F
		frame3/7 (32): $00:9c2e
			[FF03]   00 01[FF
			04]      40 41[FF
			02]02 03[FF04]
			   42 43[FF03]
			00 01 7F 02 03 7F
			40 41 7F 42 43 7F

